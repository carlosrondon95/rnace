[
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.agregar_lista_espera(p_usuario_id uuid, p_sesion_id bigint)\n RETURNS TABLE(ok boolean, mensaje text)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_sesion RECORD;\r\nBEGIN\r\n    -- Verificar que la sesión existe y no ha pasado\r\n    SELECT * INTO v_sesion FROM public.sesiones WHERE id = p_sesion_id;\r\n    \r\n    IF v_sesion IS NULL THEN\r\n        RETURN QUERY SELECT FALSE, 'Sesión no encontrada';\r\n        RETURN;\r\n    END IF;\r\n    \r\n    IF v_sesion.fecha_inicio < NOW() THEN\r\n        RETURN QUERY SELECT FALSE, 'La sesión ya ha pasado';\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- Verificar que no está ya en la lista\r\n    IF EXISTS (SELECT 1 FROM public.lista_espera WHERE sesion_id = p_sesion_id AND usuario_id = p_usuario_id) THEN\r\n        RETURN QUERY SELECT FALSE, 'Ya estás en la lista de espera de esta sesión';\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- Verificar que no tiene ya reserva en esta sesión\r\n    IF EXISTS (SELECT 1 FROM public.reservas WHERE sesion_id = p_sesion_id AND usuario_id = p_usuario_id AND estado = 'activa') THEN\r\n        RETURN QUERY SELECT FALSE, 'Ya tienes reserva en esta sesión';\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- Añadir a lista de espera\r\n    INSERT INTO public.lista_espera (sesion_id, usuario_id, creado_en)\r\n    VALUES (p_sesion_id, p_usuario_id, NOW());\r\n    \r\n    RETURN QUERY SELECT TRUE, 'Añadido a la lista de espera';\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.calcular_sesiones_mes(p_usuario_id uuid, p_anio integer, p_mes integer)\n RETURNS TABLE(sesiones_focus integer, sesiones_reducido integer)\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    v_plan RECORD;\r\n    v_semanas INT;\r\nBEGIN\r\n    -- Obtener plan del usuario\r\n    SELECT clases_focus_semana, clases_reducido_semana, activo\r\n    INTO v_plan\r\n    FROM public.plan_usuario\r\n    WHERE usuario_id = p_usuario_id;\r\n    \r\n    IF v_plan IS NULL OR v_plan.activo = FALSE THEN\r\n        RETURN QUERY SELECT 0, 0;\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- Contar semanas del mes\r\n    v_semanas := public.contar_semanas_mes(p_anio, p_mes);\r\n    \r\n    -- Calcular sesiones\r\n    RETURN QUERY SELECT \r\n        (COALESCE(v_plan.clases_focus_semana, 0) * v_semanas)::INT,\r\n        (COALESCE(v_plan.clases_reducido_semana, 0) * v_semanas)::INT;\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.cancelar_reserva(p_usuario_id uuid, p_reserva_id bigint)\n RETURNS TABLE(ok boolean, mensaje text, genera_recuperacion boolean)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_reserva RECORD;\r\n    v_sesion RECORD;\r\n    v_tiempo_hasta_clase INTERVAL;\r\n    v_cancelada_correctamente BOOLEAN := FALSE;\r\n    v_genera_recuperacion BOOLEAN := FALSE;\r\n    v_plan RECORD;\r\nBEGIN\r\n    -- 1. Obtener reserva\r\n    SELECT * INTO v_reserva\r\n    FROM public.reservas\r\n    WHERE id = p_reserva_id AND usuario_id = p_usuario_id;\r\n    \r\n    IF v_reserva IS NULL THEN\r\n        RETURN QUERY SELECT FALSE, 'Reserva no encontrada', FALSE;\r\n        RETURN;\r\n    END IF;\r\n    \r\n    IF v_reserva.estado != 'activa' THEN\r\n        RETURN QUERY SELECT FALSE, 'La reserva no está activa', FALSE;\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- 2. Obtener sesión\r\n    SELECT * INTO v_sesion\r\n    FROM public.sesiones\r\n    WHERE id = v_reserva.sesion_id;\r\n    \r\n    -- 3. Verificar tiempo de antelación (mínimo 1 hora)\r\n    v_tiempo_hasta_clase := v_sesion.fecha_inicio - NOW();\r\n    \r\n    IF v_tiempo_hasta_clase >= INTERVAL '1 hour' THEN\r\n        v_cancelada_correctamente := TRUE;\r\n    END IF;\r\n    \r\n    -- 4. Cancelar la reserva\r\n    UPDATE public.reservas\r\n    SET estado = 'cancelada',\r\n        cancelada_en = NOW(),\r\n        cancelada_correctamente = v_cancelada_correctamente\r\n    WHERE id = p_reserva_id;\r\n    \r\n    -- 5. Si se canceló correctamente y no es una recuperación, generar recuperación\r\n    IF v_cancelada_correctamente AND NOT COALESCE(v_reserva.es_recuperacion, FALSE) THEN\r\n        -- Obtener plan\r\n        SELECT * INTO v_plan FROM public.plan_usuario WHERE usuario_id = p_usuario_id;\r\n        \r\n        -- Solo generar si no tiene ya una recuperación de esa modalidad\r\n        IF v_sesion.modalidad::TEXT = 'focus' THEN\r\n            IF NOT COALESCE(v_plan.recuperacion_focus_disponible, FALSE) THEN\r\n                UPDATE public.plan_usuario\r\n                SET recuperacion_focus_disponible = TRUE,\r\n                    recuperacion_generada_en = CURRENT_DATE\r\n                WHERE usuario_id = p_usuario_id;\r\n                v_genera_recuperacion := TRUE;\r\n            END IF;\r\n        ELSE\r\n            IF NOT COALESCE(v_plan.recuperacion_reducido_disponible, FALSE) THEN\r\n                UPDATE public.plan_usuario\r\n                SET recuperacion_reducido_disponible = TRUE,\r\n                    recuperacion_generada_en = CURRENT_DATE\r\n                WHERE usuario_id = p_usuario_id;\r\n                v_genera_recuperacion := TRUE;\r\n            END IF;\r\n        END IF;\r\n    END IF;\r\n    \r\n    -- 6. Notificar al primero de la lista de espera (si hay)\r\n    PERFORM public.notificar_hueco_disponible(v_reserva.sesion_id);\r\n    \r\n    IF v_cancelada_correctamente THEN\r\n        IF v_genera_recuperacion THEN\r\n            RETURN QUERY SELECT TRUE, 'Reserva cancelada. Se ha generado una recuperación para el mes siguiente.', TRUE;\r\n        ELSE\r\n            RETURN QUERY SELECT TRUE, 'Reserva cancelada correctamente.', FALSE;\r\n        END IF;\r\n    ELSE\r\n        RETURN QUERY SELECT TRUE, 'Reserva cancelada. No se genera recuperación por cancelar con menos de 1 hora de antelación.', FALSE;\r\n    END IF;\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.contar_reservas_usuario_mes(p_usuario_id uuid, p_anio integer, p_mes integer)\n RETURNS TABLE(total_focus integer, total_reducido integer)\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    v_inicio_mes DATE;\r\n    v_fin_mes DATE;\r\nBEGIN\r\n    v_inicio_mes := make_date(p_anio, p_mes, 1);\r\n    v_fin_mes := (v_inicio_mes + INTERVAL '1 month - 1 day')::DATE;\r\n    \r\n    RETURN QUERY\r\n    SELECT \r\n        COALESCE(SUM(CASE WHEN s.modalidad::TEXT = 'focus' THEN 1 ELSE 0 END), 0)::INT,\r\n        COALESCE(SUM(CASE WHEN s.modalidad::TEXT = 'reducido' THEN 1 ELSE 0 END), 0)::INT\r\n    FROM public.reservas r\r\n    JOIN public.sesiones s ON r.sesion_id = s.id\r\n    WHERE r.usuario_id = p_usuario_id\r\n      AND r.estado = 'activa'\r\n      AND s.fecha_inicio::DATE >= v_inicio_mes\r\n      AND s.fecha_inicio::DATE <= v_fin_mes\r\n      AND s.cancelada = FALSE;\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.contar_reservas_usuario_semana(p_usuario_id uuid, p_fecha date)\n RETURNS TABLE(total_focus integer, total_reducido integer)\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    v_inicio_semana DATE;\r\n    v_fin_semana DATE;\r\nBEGIN\r\n    v_inicio_semana := public.inicio_semana(p_fecha);\r\n    v_fin_semana := v_inicio_semana + 4; -- Lunes a viernes\r\n    \r\n    RETURN QUERY\r\n    SELECT \r\n        COALESCE(SUM(CASE WHEN s.modalidad::TEXT = 'focus' THEN 1 ELSE 0 END), 0)::INT,\r\n        COALESCE(SUM(CASE WHEN s.modalidad::TEXT = 'reducido' THEN 1 ELSE 0 END), 0)::INT\r\n    FROM public.reservas r\r\n    JOIN public.sesiones s ON r.sesion_id = s.id\r\n    WHERE r.usuario_id = p_usuario_id\r\n      AND r.estado = 'activa'\r\n      AND s.fecha_inicio::DATE >= v_inicio_semana\r\n      AND s.fecha_inicio::DATE <= v_fin_semana\r\n      AND s.cancelada = FALSE;\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.contar_semanas_mes(p_anio integer, p_mes integer)\n RETURNS integer\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\r\nDECLARE\r\n    v_primer_dia DATE;\r\n    v_ultimo_dia DATE;\r\n    v_primer_lunes DATE;\r\n    v_ultimo_viernes DATE;\r\n    v_semanas INT;\r\nBEGIN\r\n    v_primer_dia := make_date(p_anio, p_mes, 1);\r\n    v_ultimo_dia := (v_primer_dia + INTERVAL '1 month - 1 day')::DATE;\r\n    \r\n    -- Encontrar el primer lunes del mes\r\n    v_primer_lunes := v_primer_dia + ((8 - EXTRACT(DOW FROM v_primer_dia)::INT) % 7);\r\n    IF v_primer_lunes > v_ultimo_dia THEN\r\n        RETURN 0;\r\n    END IF;\r\n    \r\n    -- Encontrar el último viernes del mes\r\n    v_ultimo_viernes := v_ultimo_dia - ((EXTRACT(DOW FROM v_ultimo_dia)::INT + 2) % 7);\r\n    IF v_ultimo_viernes < v_primer_lunes THEN\r\n        RETURN 0;\r\n    END IF;\r\n    \r\n    -- Contar semanas entre primer lunes y último viernes\r\n    v_semanas := FLOOR((v_ultimo_viernes - v_primer_lunes) / 7)::INT + 1;\r\n    \r\n    RETURN v_semanas;\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.crear_reserva(p_usuario_id uuid, p_sesion_id bigint, p_es_recuperacion boolean DEFAULT false)\n RETURNS TABLE(ok boolean, mensaje text, reserva_id bigint)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_validacion RECORD;\r\n    v_nueva_reserva_id BIGINT;\r\n    v_sesion RECORD;\r\nBEGIN\r\n    -- Validar\r\n    SELECT * INTO v_validacion\r\n    FROM public.puede_reservar(p_usuario_id, p_sesion_id, p_es_recuperacion);\r\n    \r\n    IF NOT v_validacion.ok THEN\r\n        RETURN QUERY SELECT FALSE, v_validacion.mensaje, NULL::BIGINT;\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- Obtener modalidad de la sesión\r\n    SELECT modalidad INTO v_sesion FROM public.sesiones WHERE id = p_sesion_id;\r\n    \r\n    -- Crear reserva\r\n    INSERT INTO public.reservas (sesion_id, usuario_id, estado, es_recuperacion, creada_en)\r\n    VALUES (p_sesion_id, p_usuario_id, 'activa', p_es_recuperacion, NOW())\r\n    RETURNING id INTO v_nueva_reserva_id;\r\n    \r\n    -- Si es recuperación, marcar como usada\r\n    IF p_es_recuperacion THEN\r\n        IF v_sesion.modalidad::TEXT = 'focus' THEN\r\n            UPDATE public.plan_usuario\r\n            SET recuperacion_focus_disponible = FALSE\r\n            WHERE usuario_id = p_usuario_id;\r\n        ELSE\r\n            UPDATE public.plan_usuario\r\n            SET recuperacion_reducido_disponible = FALSE\r\n            WHERE usuario_id = p_usuario_id;\r\n        END IF;\r\n    END IF;\r\n    \r\n    -- Eliminar de lista de espera si estaba\r\n    DELETE FROM public.lista_espera\r\n    WHERE sesion_id = p_sesion_id AND usuario_id = p_usuario_id;\r\n    \r\n    RETURN QUERY SELECT TRUE, 'Reserva creada correctamente', v_nueva_reserva_id;\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.es_festivo(p_fecha date)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nBEGIN\r\n    RETURN EXISTS (\r\n        SELECT 1 FROM public.festivos WHERE fecha = p_fecha\r\n    );\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.es_mes_abierto(p_anio integer, p_mes integer)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    v_abierto BOOLEAN;\r\nBEGIN\r\n    SELECT abierto INTO v_abierto\r\n    FROM public.agenda_mes\r\n    WHERE anio = p_anio AND mes = p_mes;\r\n    \r\n    RETURN COALESCE(v_abierto, FALSE);\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nBEGIN\r\n    INSERT INTO public.perfiles (id, nombre, telefono, rol, creado_en)\r\n    VALUES (\r\n        NEW.id,\r\n        COALESCE(NEW.raw_user_meta_data->>'nombre', ''),\r\n        COALESCE(NEW.phone, NEW.raw_user_meta_data->>'telefono', ''),\r\n        COALESCE(NEW.raw_user_meta_data->>'rol', 'cliente'),\r\n        NOW()\r\n    );\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.handle_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    NEW.actualizado_en = NOW();\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.inicio_semana(p_fecha date)\n RETURNS date\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\r\nBEGIN\r\n    -- DOW: 0=domingo, 1=lunes, ..., 6=sábado\r\n    -- Si es domingo (0), retrocedemos 6 días\r\n    -- Si es lunes (1), retrocedemos 0 días, etc.\r\n    RETURN p_fecha - ((EXTRACT(DOW FROM p_fecha)::INT + 6) % 7);\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.limpiar_recuperaciones_expiradas()\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_hoy DATE := CURRENT_DATE;\r\n    v_mes_actual INT := EXTRACT(MONTH FROM v_hoy)::INT;\r\n    v_anio_actual INT := EXTRACT(YEAR FROM v_hoy)::INT;\r\n    v_contador INT;\r\nBEGIN\r\n    -- Las recuperaciones solo valen para el mes siguiente al que se generaron\r\n    -- Si estamos en mes M, expiran las que se generaron antes del mes M-1\r\n    \r\n    UPDATE public.plan_usuario\r\n    SET recuperacion_focus_disponible = FALSE,\r\n        recuperacion_reducido_disponible = FALSE,\r\n        recuperacion_generada_en = NULL\r\n    WHERE recuperacion_generada_en IS NOT NULL\r\n      AND (\r\n          -- Si la recuperación se generó hace más de 2 meses\r\n          (v_anio_actual > EXTRACT(YEAR FROM recuperacion_generada_en)::INT + 1) OR\r\n          (v_anio_actual = EXTRACT(YEAR FROM recuperacion_generada_en)::INT AND \r\n           v_mes_actual > EXTRACT(MONTH FROM recuperacion_generada_en)::INT + 1) OR\r\n          (v_anio_actual = EXTRACT(YEAR FROM recuperacion_generada_en)::INT + 1 AND \r\n           EXTRACT(MONTH FROM recuperacion_generada_en)::INT < 11 AND\r\n           v_mes_actual > EXTRACT(MONTH FROM recuperacion_generada_en)::INT - 11)\r\n      );\r\n    \r\n    GET DIAGNOSTICS v_contador = ROW_COUNT;\r\n    RETURN v_contador;\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.notificar_hueco_disponible(p_sesion_id bigint)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_primer_espera RECORD;\r\n    v_sesion RECORD;\r\n    v_mensaje TEXT;\r\nBEGIN\r\n    -- Obtener primer usuario en espera\r\n    SELECT le.*, p.nombre\r\n    INTO v_primer_espera\r\n    FROM public.lista_espera le\r\n    JOIN public.perfiles p ON le.usuario_id = p.id\r\n    WHERE le.sesion_id = p_sesion_id\r\n    ORDER BY le.creado_en ASC\r\n    LIMIT 1;\r\n    \r\n    IF v_primer_espera IS NULL THEN\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- Obtener datos de la sesión\r\n    SELECT * INTO v_sesion FROM public.sesiones WHERE id = p_sesion_id;\r\n    \r\n    -- Crear mensaje\r\n    v_mensaje := format(\r\n        '¡Hay una plaza disponible! Sesión de %s el %s a las %s',\r\n        v_sesion.modalidad::TEXT,\r\n        TO_CHAR(v_sesion.fecha_inicio, 'DD/MM/YYYY'),\r\n        TO_CHAR(v_sesion.fecha_inicio, 'HH24:MI')\r\n    );\r\n    \r\n    -- Crear notificación\r\n    INSERT INTO public.notificaciones (\r\n        usuario_id, \r\n        tipo, \r\n        mensaje, \r\n        sesion_id, \r\n        accion_url,\r\n        leida,\r\n        procesada,\r\n        creado_en\r\n    ) VALUES (\r\n        v_primer_espera.usuario_id,\r\n        'hueco_disponible',\r\n        v_mensaje,\r\n        p_sesion_id,\r\n        format('/reservar-cita?sesion=%s', p_sesion_id),\r\n        FALSE,\r\n        FALSE,\r\n        NOW()\r\n    );\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.obtener_cupos_usuario(p_usuario_id uuid, p_anio integer, p_mes integer)\n RETURNS TABLE(tipo_grupo text, sesiones_focus_mes integer, sesiones_reducido_mes integer, usadas_focus_mes integer, usadas_reducido_mes integer, disponibles_focus_mes integer, disponibles_reducido_mes integer, tiene_recuperacion_focus boolean, tiene_recuperacion_reducido boolean, recuperacion_mes_origen text)\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    v_plan RECORD;\r\n    v_sesiones RECORD;\r\n    v_usadas RECORD;\r\nBEGIN\r\n    -- Obtener plan\r\n    SELECT * INTO v_plan FROM public.plan_usuario WHERE usuario_id = p_usuario_id;\r\n    \r\n    IF v_plan IS NULL THEN\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- Calcular sesiones del mes\r\n    SELECT * INTO v_sesiones FROM public.calcular_sesiones_mes(p_usuario_id, p_anio, p_mes);\r\n    \r\n    -- Contar usadas\r\n    SELECT * INTO v_usadas FROM public.contar_reservas_usuario_mes(p_usuario_id, p_anio, p_mes);\r\n    \r\n    RETURN QUERY SELECT\r\n        COALESCE(v_plan.tipo_grupo::TEXT, 'sin_plan'),\r\n        v_sesiones.sesiones_focus,\r\n        v_sesiones.sesiones_reducido,\r\n        v_usadas.total_focus,\r\n        v_usadas.total_reducido,\r\n        GREATEST(v_sesiones.sesiones_focus - v_usadas.total_focus, 0),\r\n        GREATEST(v_sesiones.sesiones_reducido - v_usadas.total_reducido, 0),\r\n        COALESCE(v_plan.recuperacion_focus_disponible, FALSE),\r\n        COALESCE(v_plan.recuperacion_reducido_disponible, FALSE),\r\n        CASE \r\n            WHEN v_plan.recuperacion_generada_en IS NOT NULL \r\n            THEN TO_CHAR(v_plan.recuperacion_generada_en, 'MM/YYYY')\r\n            ELSE NULL\r\n        END;\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.procesar_festivo(p_fecha date)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_reserva RECORD;\r\n    v_contador INT := 0;\r\nBEGIN\r\n    -- Buscar todas las reservas activas de ese día\r\n    FOR v_reserva IN \r\n        SELECT r.*, s.modalidad\r\n        FROM public.reservas r\r\n        JOIN public.sesiones s ON r.sesion_id = s.id\r\n        WHERE s.fecha_inicio::DATE = p_fecha\r\n          AND r.estado = 'activa'\r\n    LOOP\r\n        -- Cancelar la reserva\r\n        UPDATE public.reservas\r\n        SET estado = 'cancelada',\r\n            cancelada_en = NOW(),\r\n            cancelada_correctamente = TRUE\r\n        WHERE id = v_reserva.id;\r\n        \r\n        -- Generar recuperación (mismo lógica que cancelar_reserva)\r\n        IF v_reserva.modalidad::TEXT = 'focus' THEN\r\n            UPDATE public.plan_usuario\r\n            SET recuperacion_focus_disponible = TRUE,\r\n                recuperacion_generada_en = p_fecha\r\n            WHERE usuario_id = v_reserva.usuario_id\r\n              AND NOT COALESCE(recuperacion_focus_disponible, FALSE);\r\n        ELSE\r\n            UPDATE public.plan_usuario\r\n            SET recuperacion_reducido_disponible = TRUE,\r\n                recuperacion_generada_en = p_fecha\r\n            WHERE usuario_id = v_reserva.usuario_id\r\n              AND NOT COALESCE(recuperacion_reducido_disponible, FALSE);\r\n        END IF;\r\n        \r\n        -- Notificar al usuario\r\n        INSERT INTO public.notificaciones (usuario_id, tipo, mensaje, creado_en)\r\n        VALUES (\r\n            v_reserva.usuario_id,\r\n            'festivo',\r\n            format('Tu clase del %s ha sido cancelada por festivo. Se ha generado una recuperación para el mes siguiente.', TO_CHAR(p_fecha, 'DD/MM/YYYY')),\r\n            NOW()\r\n        );\r\n        \r\n        v_contador := v_contador + 1;\r\n    END LOOP;\r\n    \r\n    RETURN v_contador;\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.puede_reservar(p_usuario_id uuid, p_sesion_id bigint, p_es_recuperacion boolean DEFAULT false)\n RETURNS TABLE(ok boolean, mensaje text)\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    v_sesion RECORD;\r\n    v_plan RECORD;\r\n    v_reservas_semana RECORD;\r\n    v_reservas_mes RECORD;\r\n    v_sesiones_mes RECORD;\r\n    v_plazas_ocupadas INT;\r\nBEGIN\r\n    -- 1. Obtener datos de la sesión\r\n    SELECT s.*, s.fecha_inicio::DATE as fecha\r\n    INTO v_sesion\r\n    FROM public.sesiones s\r\n    WHERE s.id = p_sesion_id;\r\n    \r\n    IF v_sesion IS NULL THEN\r\n        RETURN QUERY SELECT FALSE, 'La sesión no existe';\r\n        RETURN;\r\n    END IF;\r\n    \r\n    IF v_sesion.cancelada THEN\r\n        RETURN QUERY SELECT FALSE, 'La sesión está cancelada';\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- 2. Verificar que el mes está abierto\r\n    IF NOT public.es_mes_abierto(EXTRACT(YEAR FROM v_sesion.fecha)::INT, EXTRACT(MONTH FROM v_sesion.fecha)::INT) THEN\r\n        RETURN QUERY SELECT FALSE, 'El mes no está abierto para reservas';\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- 3. Verificar que no es festivo\r\n    IF public.es_festivo(v_sesion.fecha) THEN\r\n        RETURN QUERY SELECT FALSE, 'Es un día festivo';\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- 4. Verificar que la sesión no ha pasado\r\n    IF v_sesion.fecha_inicio < NOW() THEN\r\n        RETURN QUERY SELECT FALSE, 'La sesión ya ha comenzado o pasado';\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- 5. Obtener plan del usuario\r\n    SELECT * INTO v_plan\r\n    FROM public.plan_usuario\r\n    WHERE usuario_id = p_usuario_id;\r\n    \r\n    IF v_plan IS NULL OR v_plan.activo = FALSE THEN\r\n        RETURN QUERY SELECT FALSE, 'No tienes un plan activo';\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- 6. Verificar que no tiene clase ese día\r\n    IF public.tiene_clase_ese_dia(p_usuario_id, v_sesion.fecha) THEN\r\n        RETURN QUERY SELECT FALSE, 'Ya tienes una clase reservada este día';\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- 7. Verificar plazas disponibles\r\n    SELECT COUNT(*) INTO v_plazas_ocupadas\r\n    FROM public.reservas\r\n    WHERE sesion_id = p_sesion_id AND estado = 'activa';\r\n    \r\n    IF v_plazas_ocupadas >= v_sesion.capacidad THEN\r\n        RETURN QUERY SELECT FALSE, 'No hay plazas disponibles en esta sesión';\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- 8. Si es recuperación, validar que tiene recuperación disponible de esa modalidad\r\n    IF p_es_recuperacion THEN\r\n        IF v_sesion.modalidad::TEXT = 'focus' AND NOT COALESCE(v_plan.recuperacion_focus_disponible, FALSE) THEN\r\n            RETURN QUERY SELECT FALSE, 'No tienes recuperación de Focus disponible';\r\n            RETURN;\r\n        END IF;\r\n        \r\n        IF v_sesion.modalidad::TEXT = 'reducido' AND NOT COALESCE(v_plan.recuperacion_reducido_disponible, FALSE) THEN\r\n            RETURN QUERY SELECT FALSE, 'No tienes recuperación de Reducido disponible';\r\n            RETURN;\r\n        END IF;\r\n        \r\n        -- Verificar que la recuperación es válida para este mes (mes siguiente al que se generó)\r\n        IF v_plan.recuperacion_generada_en IS NOT NULL THEN\r\n            DECLARE\r\n                v_mes_recuperacion INT;\r\n                v_anio_recuperacion INT;\r\n                v_mes_sesion INT;\r\n                v_anio_sesion INT;\r\n            BEGIN\r\n                v_mes_recuperacion := EXTRACT(MONTH FROM v_plan.recuperacion_generada_en)::INT;\r\n                v_anio_recuperacion := EXTRACT(YEAR FROM v_plan.recuperacion_generada_en)::INT;\r\n                v_mes_sesion := EXTRACT(MONTH FROM v_sesion.fecha)::INT;\r\n                v_anio_sesion := EXTRACT(YEAR FROM v_sesion.fecha)::INT;\r\n                \r\n                -- La recuperación solo vale para el mes siguiente\r\n                IF NOT (\r\n                    (v_anio_sesion = v_anio_recuperacion AND v_mes_sesion = v_mes_recuperacion + 1) OR\r\n                    (v_anio_sesion = v_anio_recuperacion + 1 AND v_mes_recuperacion = 12 AND v_mes_sesion = 1)\r\n                ) THEN\r\n                    RETURN QUERY SELECT FALSE, 'La recuperación solo es válida para el mes siguiente';\r\n                    RETURN;\r\n                END IF;\r\n            END;\r\n        END IF;\r\n        \r\n        -- Si es recuperación válida, puede reservar\r\n        RETURN QUERY SELECT TRUE, 'OK';\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- 9. Verificar cupo semanal\r\n    SELECT * INTO v_reservas_semana\r\n    FROM public.contar_reservas_usuario_semana(p_usuario_id, v_sesion.fecha);\r\n    \r\n    IF v_sesion.modalidad::TEXT = 'focus' THEN\r\n        IF v_reservas_semana.total_focus >= COALESCE(v_plan.clases_focus_semana, 0) THEN\r\n            RETURN QUERY SELECT FALSE, 'Has alcanzado el límite semanal de clases Focus';\r\n            RETURN;\r\n        END IF;\r\n    ELSE\r\n        IF v_reservas_semana.total_reducido >= COALESCE(v_plan.clases_reducido_semana, 0) THEN\r\n            RETURN QUERY SELECT FALSE, 'Has alcanzado el límite semanal de clases Reducido';\r\n            RETURN;\r\n        END IF;\r\n    END IF;\r\n    \r\n    -- 10. Verificar cupo mensual\r\n    SELECT * INTO v_reservas_mes\r\n    FROM public.contar_reservas_usuario_mes(\r\n        p_usuario_id, \r\n        EXTRACT(YEAR FROM v_sesion.fecha)::INT, \r\n        EXTRACT(MONTH FROM v_sesion.fecha)::INT\r\n    );\r\n    \r\n    SELECT * INTO v_sesiones_mes\r\n    FROM public.calcular_sesiones_mes(\r\n        p_usuario_id,\r\n        EXTRACT(YEAR FROM v_sesion.fecha)::INT,\r\n        EXTRACT(MONTH FROM v_sesion.fecha)::INT\r\n    );\r\n    \r\n    IF v_sesion.modalidad::TEXT = 'focus' THEN\r\n        IF v_reservas_mes.total_focus >= v_sesiones_mes.sesiones_focus THEN\r\n            RETURN QUERY SELECT FALSE, 'Has alcanzado el límite mensual de clases Focus';\r\n            RETURN;\r\n        END IF;\r\n    ELSE\r\n        IF v_reservas_mes.total_reducido >= v_sesiones_mes.sesiones_reducido THEN\r\n            RETURN QUERY SELECT FALSE, 'Has alcanzado el límite mensual de clases Reducido';\r\n            RETURN;\r\n        END IF;\r\n    END IF;\r\n    \r\n    -- Todo OK\r\n    RETURN QUERY SELECT TRUE, 'OK';\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.tiene_clase_ese_dia(p_usuario_id uuid, p_fecha date)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nBEGIN\r\n    RETURN EXISTS (\r\n        SELECT 1 \r\n        FROM public.reservas r\r\n        JOIN public.sesiones s ON r.sesion_id = s.id\r\n        WHERE r.usuario_id = p_usuario_id\r\n          AND r.estado = 'activa'\r\n          AND s.fecha_inicio::DATE = p_fecha\r\n          AND s.cancelada = FALSE\r\n    );\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.trigger_procesar_festivo()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Procesar las reservas del día festivo\r\n    PERFORM public.procesar_festivo(NEW.fecha);\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.trigger_reserva_cancelada()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Si la reserva cambió a cancelada\r\n    IF OLD.estado = 'activa' AND NEW.estado = 'cancelada' THEN\r\n        PERFORM public.notificar_hueco_disponible(NEW.sesion_id);\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.trigger_validar_reserva()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_validacion RECORD;\r\nBEGIN\r\n    -- Solo validar si es una reserva nueva activa\r\n    IF NEW.estado = 'activa' THEN\r\n        SELECT * INTO v_validacion\r\n        FROM public.puede_reservar(NEW.usuario_id, NEW.sesion_id, COALESCE(NEW.es_recuperacion, FALSE));\r\n        \r\n        IF NOT v_validacion.ok THEN\r\n            RAISE EXCEPTION '%', v_validacion.mensaje;\r\n        END IF;\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  }
]