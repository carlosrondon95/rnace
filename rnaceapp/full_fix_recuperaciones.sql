-- =====================================================
-- CORRECCIÓN: Eliminar restricción y aplicar Lógica V3
-- =====================================================

-- 1. ELIMINAR LA RESTRICCIÓN QUE DA ERROR (Unique Key antiguo)
ALTER TABLE public.recuperaciones DROP CONSTRAINT IF EXISTS recuperaciones_usuario_id_key;

-- 2. CORREGIR LA CLAVE FORÁNEA (Foreign Key)
ALTER TABLE public.recuperaciones DROP CONSTRAINT IF EXISTS recuperaciones_usuario_id_fkey;

DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.table_constraints 
        WHERE constraint_name = 'recuperaciones_usuario_id_fkey'
    ) THEN
        ALTER TABLE public.recuperaciones 
        ADD CONSTRAINT recuperaciones_usuario_id_fkey 
        FOREIGN KEY (usuario_id) 
        REFERENCES public.usuarios(id);
    END IF;
END $$;

-- 3. Asegurar estructura de tabla recuperaciones (por si faltan columnas)
CREATE TABLE IF NOT EXISTS recuperaciones (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    usuario_id UUID REFERENCES public.usuarios(id) NOT NULL,
    sesion_cancelada_id BIGINT,
    modalidad TEXT NOT NULL,
    mes_origen INT NOT NULL,
    anio_origen INT NOT NULL,
    mes_limite INT NOT NULL,
    anio_limite INT NOT NULL,
    estado TEXT DEFAULT 'disponible',
    fecha_creacion TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    fecha_uso TIMESTAMP WITH TIME ZONE,
    sesion_uso_id BIGINT,
    mes_uso INT,
    anio_uso INT
);

ALTER TABLE public.recuperaciones 
ADD COLUMN IF NOT EXISTS sesion_uso_id BIGINT,
ADD COLUMN IF NOT EXISTS mes_uso INT,
ADD COLUMN IF NOT EXISTS anio_uso INT;

-- 4. DEFINIR FUNCIONES DE LÓGICA (V3)

-- A. Cancelar Reserva
DROP FUNCTION IF EXISTS cancelar_reserva(uuid, bigint);

CREATE OR REPLACE FUNCTION cancelar_reserva(
  p_usuario_id UUID,
  p_reserva_id BIGINT
)
RETURNS TABLE (ok BOOLEAN, mensaje TEXT)
LANGUAGE plpgsql
AS $func$
DECLARE
  v_sesion_id BIGINT;
  v_fecha DATE;
  v_modalidad TEXT;
  v_estado_reserva TEXT;
  v_mes_origen INT;
  v_anio_origen INT;
  v_mes_limite INT;
  v_anio_limite INT;
  v_ahora TIMESTAMP;
  v_tiempo_limite TIMESTAMP;
BEGIN
  v_ahora := NOW();

  -- Obtener datos de la reserva y sesión
  SELECT r.sesion_id, r.estado, s.fecha, s.modalidad, (s.fecha + s.hora)
  INTO v_sesion_id, v_estado_reserva, v_fecha, v_modalidad, v_tiempo_limite
  FROM reservas r
  JOIN sesiones s ON s.id = r.sesion_id
  WHERE r.id = p_reserva_id AND r.usuario_id = p_usuario_id;

  IF v_sesion_id IS NULL THEN
    RETURN QUERY SELECT false, 'Reserva no encontrada.';
    RETURN;
  END IF;

  IF v_estado_reserva != 'activa' THEN
    RETURN QUERY SELECT false, 'La reserva no está activa.';
    RETURN;
  END IF;

  -- Validar tiempo de cancelación (1 hora antes)
  IF v_tiempo_limite < (v_ahora + INTERVAL '1 hour') THEN
    RETURN QUERY SELECT false, 'Es demasiado tarde para cancelar (mínimo 1 hora antes).';
    RETURN;
  END IF;

  -- Calcular fechas de validez basado en la FECHA DE LA CLASE
  v_mes_origen := EXTRACT(MONTH FROM v_fecha);
  v_anio_origen := EXTRACT(YEAR FROM v_fecha);
  
  -- Validez: mes de la clase y el siguiente
  IF v_mes_origen = 12 THEN
    v_mes_limite := 1;
    v_anio_limite := v_anio_origen + 1;
  ELSE
    v_mes_limite := v_mes_origen + 1;
    v_anio_limite := v_anio_origen;
  END IF;

  -- Actualizar reserva
  UPDATE reservas 
  SET estado = 'cancelada', cancelada_en = v_ahora
  WHERE id = p_reserva_id;

  -- Generar recuperación
  INSERT INTO recuperaciones (
    usuario_id,
    sesion_cancelada_id,
    modalidad,
    mes_origen,
    anio_origen,
    mes_limite,
    anio_limite,
    estado
  ) VALUES (
    p_usuario_id,
    v_sesion_id,
    v_modalidad,
    v_mes_origen,
    v_anio_origen,
    v_mes_limite,
    v_anio_limite,
    'disponible'
  );

  -- Notificar hueco
  PERFORM notificar_hueco_disponible(v_sesion_id);

  RETURN QUERY SELECT true, 'Clase cancelada. Se ha generado una recuperación.';
END;
$func$;

-- B. Usar Recuperación
DROP FUNCTION IF EXISTS usar_recuperacion(uuid, bigint);

CREATE OR REPLACE FUNCTION usar_recuperacion(
  p_usuario_id UUID,
  p_sesion_id BIGINT
)
RETURNS TABLE (ok BOOLEAN, mensaje TEXT)
LANGUAGE plpgsql
AS $func$
DECLARE
  v_sesion_fecha DATE;
  v_sesion_modalidad TEXT;
  v_capacidad INT;
  v_ocupadas INT;
  v_mes_destino INT;
  v_anio_destino INT;
  v_recuperacion_id BIGINT;
  v_recu_mes_origen INT;
  v_recu_anio_origen INT;
  v_count_usadas_next_month INT;
BEGIN
  -- Verificar sesión
  SELECT fecha, modalidad, capacidad
  INTO v_sesion_fecha, v_sesion_modalidad, v_capacidad
  FROM sesiones 
  WHERE id = p_sesion_id AND cancelada = false;

  IF v_sesion_fecha IS NULL THEN
    RETURN QUERY SELECT false, 'Sesión no encontrada.';
    RETURN;
  END IF;

  v_mes_destino := EXTRACT(MONTH FROM v_sesion_fecha);
  v_anio_destino := EXTRACT(YEAR FROM v_sesion_fecha);

  -- Verificar disponibilidad
  SELECT COUNT(*) INTO v_ocupadas FROM reservas WHERE sesion_id = p_sesion_id AND estado = 'activa';
  
  IF v_ocupadas >= v_capacidad THEN
    RETURN QUERY SELECT false, 'La clase está completa.';
    RETURN;
  END IF;

  IF EXISTS (SELECT 1 FROM reservas WHERE usuario_id = p_usuario_id AND sesion_id = p_sesion_id AND estado = 'activa') THEN
    RETURN QUERY SELECT false, 'Ya tienes reserva en esta clase.';
    RETURN;
  END IF;

  -- A. Prioridad: Recuperación del MISMO mes (no gasta cupo 'next month')
  SELECT id, mes_origen, anio_origen
  INTO v_recuperacion_id, v_recu_mes_origen, v_recu_anio_origen
  FROM recuperaciones
  WHERE usuario_id = p_usuario_id 
    AND estado = 'disponible'
    AND modalidad = v_sesion_modalidad
    AND mes_origen = v_mes_destino
    AND anio_origen = v_anio_destino
  LIMIT 1;

  -- B. Si no, buscar del mes anterior (Sujeto a límite de 1)
  IF v_recuperacion_id IS NULL THEN
    
    -- Contar cuántas "arrastradas" ya se han usado este mes
    SELECT COUNT(*)
    INTO v_count_usadas_next_month
    FROM recuperaciones
    WHERE usuario_id = p_usuario_id
      AND mes_uso = v_mes_destino
      AND anio_uso = v_anio_destino
      AND (mes_origen != v_mes_destino OR anio_origen != v_anio_destino)
      AND estado = 'usada';

    IF v_count_usadas_next_month >= 1 THEN
      RETURN QUERY SELECT false, 'Ya has usado tu única recuperación permitida del mes anterior para este mes.';
      RETURN;
    END IF;

    -- Buscar una recuperación válida de meses anteriores
    SELECT id, mes_origen, anio_origen
    INTO v_recuperacion_id, v_recu_mes_origen, v_recu_anio_origen
    FROM recuperaciones
    WHERE usuario_id = p_usuario_id
      AND estado = 'disponible'
      AND modalidad = v_sesion_modalidad
      AND (
        (anio_limite > v_anio_destino) OR 
        (anio_limite = v_anio_destino AND mes_limite >= v_mes_destino)
      )
      -- BUGFIX: Que la recuperación NO sea del futuro respecto a la clase destino
      AND (
        (anio_origen < v_anio_destino) OR
        (anio_origen = v_anio_destino AND mes_origen <= v_mes_destino)
      )
      AND (mes_origen != v_mes_destino OR anio_origen != v_anio_destino)
    ORDER BY fecha_creacion ASC
    LIMIT 1;
    
    IF v_recuperacion_id IS NULL THEN
      RETURN QUERY SELECT false, 'No tienes recuperaciones válidas (' || v_sesion_modalidad || ') para esta fecha.';
      RETURN;
    END IF;

  END IF;

  -- Ejecutar uso
  UPDATE recuperaciones
  SET estado = 'usada',
      fecha_uso = NOW(),
      sesion_uso_id = p_sesion_id,
      mes_uso = v_mes_destino,
      anio_uso = v_anio_destino
  WHERE id = v_recuperacion_id;

  INSERT INTO reservas (sesion_id, usuario_id, estado, es_recuperacion, es_desde_horario_fijo)
  VALUES (p_sesion_id, p_usuario_id, 'activa', true, false);

  DELETE FROM lista_espera WHERE usuario_id = p_usuario_id AND sesion_id = p_sesion_id;

  RETURN QUERY SELECT true, 'Recuperación aplicada correctamente.';
END;
$func$;

-- C. (NUEVO) Obtener Recuperaciones Disponibles
-- Esta función es usada por el Dashboard
DROP FUNCTION IF EXISTS obtener_recuperaciones_usuario(uuid);

CREATE OR REPLACE FUNCTION obtener_recuperaciones_usuario(p_usuario_id UUID)
RETURNS TABLE (
    id BIGINT,
    modalidad TEXT,
    mes_limite INT,
    anio_limite INT,
    mes_origen INT,
    anio_origen INT
)
LANGUAGE plpgsql
AS $func$
BEGIN
    RETURN QUERY
    SELECT 
        r.id, 
        r.modalidad,
        -- LOGICA DINÁMICA DE VISUALIZACIÓN
        CASE 
            WHEN r.mes_limite != r.mes_origen THEN
                CASE
                    WHEN (
                        SELECT COUNT(*)
                        FROM recuperaciones usage
                        WHERE usage.usuario_id = r.usuario_id
                          AND usage.estado = 'usada'
                          AND usage.mes_uso = r.mes_limite
                          AND usage.anio_uso = r.anio_limite
                          AND (usage.mes_origen != usage.mes_uso OR usage.anio_origen != usage.anio_uso)
                    ) >= 1 THEN
                        r.mes_origen
                    ELSE
                        r.mes_limite
                END
            ELSE
                r.mes_limite
        END as mes_limite,
        CASE 
             WHEN r.mes_limite != r.mes_origen THEN
                CASE
                    WHEN (
                        SELECT COUNT(*)
                        FROM recuperaciones usage
                        WHERE usage.usuario_id = r.usuario_id
                          AND usage.estado = 'usada'
                          AND usage.mes_uso = r.mes_limite
                          AND usage.anio_uso = r.anio_limite
                          AND (usage.mes_origen != usage.mes_uso OR usage.anio_origen != usage.anio_uso)
                    ) >= 1 THEN
                        r.anio_origen
                    ELSE
                        r.anio_limite
                END
            ELSE
                r.anio_limite
        END as anio_limite,
        r.mes_origen,
        r.anio_origen
    FROM recuperaciones r
    WHERE r.usuario_id = p_usuario_id
      AND r.estado = 'disponible'
    ORDER BY anio_limite ASC, mes_limite ASC;
END;
$func$;
