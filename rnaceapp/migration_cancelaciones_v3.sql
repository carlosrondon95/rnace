-- =====================================================
-- MIGRACIÓN: Sistema de Cancelaciones y Recuperaciones v3
-- =====================================================

-- 1. Asegurar estructura de tabla recuperaciones
CREATE TABLE IF NOT EXISTS recuperaciones (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    usuario_id UUID REFERENCES auth.users(id) NOT NULL,
    sesion_cancelada_id BIGINT, -- opcional, referencia a la sesión original
    modalidad TEXT NOT NULL, -- 'focus' o 'reducido'
    mes_origen INT NOT NULL,
    anio_origen INT NOT NULL,
    mes_limite INT NOT NULL,
    anio_limite INT NOT NULL,
    estado TEXT DEFAULT 'disponible', -- 'disponible', 'usada', 'caducada'
    fecha_creacion TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    fecha_uso TIMESTAMP WITH TIME ZONE,
    sesion_uso_id BIGINT, -- en qué sesión se gastó
    mes_uso INT, -- mes de la sesión donde se usó
    anio_uso INT -- año de la sesión donde se usó
);

-- Asegurar columnas de rastreo de uso
ALTER TABLE recuperaciones 
ADD COLUMN IF NOT EXISTS sesion_uso_id BIGINT,
ADD COLUMN IF NOT EXISTS mes_uso INT,
ADD COLUMN IF NOT EXISTS anio_uso INT;

-- =====================================================
-- 2. Función: Cancelar Reserva
-- =====================================================

-- Eliminar versión anterior para evitar conflictos de tipo de retorno
DROP FUNCTION IF EXISTS cancelar_reserva(uuid, bigint);

CREATE OR REPLACE FUNCTION cancelar_reserva(
  p_usuario_id UUID,
  p_reserva_id BIGINT
)
RETURNS TABLE (ok BOOLEAN, mensaje TEXT)
LANGUAGE plpgsql
AS $func$
DECLARE
  v_sesion_id BIGINT;
  v_fecha DATE;
  v_modalidad TEXT;
  v_estado_reserva TEXT;
  v_mes_origen INT;
  v_anio_origen INT;
  v_mes_limite INT;
  v_anio_limite INT;
  v_ahora TIMESTAMP;
  v_tiempo_limite TIMESTAMP;
BEGIN
  v_ahora := NOW();

  -- 1. Obtener datos de la reserva y sesión
  SELECT r.sesion_id, r.estado, s.fecha, s.modalidad, (s.fecha + s.hora)
  INTO v_sesion_id, v_estado_reserva, v_fecha, v_modalidad, v_tiempo_limite
  FROM reservas r
  JOIN sesiones s ON s.id = r.sesion_id
  WHERE r.id = p_reserva_id AND r.usuario_id = p_usuario_id;

  IF v_sesion_id IS NULL THEN
    RETURN QUERY SELECT false, 'Reserva no encontrada.';
    RETURN;
  END IF;

  IF v_estado_reserva != 'activa' THEN
    RETURN QUERY SELECT false, 'La reserva no está activa.';
    RETURN;
  END IF;

  -- 2. Validar tiempo de cancelación (ej. 1 hora antes)
  IF v_tiempo_limite < (v_ahora + INTERVAL '1 hour') THEN
    RETURN QUERY SELECT false, 'Es demasiado tarde para cancelar (mínimo 1 hora antes).';
    RETURN;
  END IF;

  -- 3. Calcular fechas de validez de la recuperación
  v_mes_origen := EXTRACT(MONTH FROM v_fecha);
  v_anio_origen := EXTRACT(YEAR FROM v_fecha);
  
  -- Validez: mes actual y mes siguiente
  IF v_mes_origen = 12 THEN
    v_mes_limite := 1;
    v_anio_limite := v_anio_origen + 1;
  ELSE
    v_mes_limite := v_mes_origen + 1;
    v_anio_limite := v_anio_origen;
  END IF;

  -- 4. Actualizar reserva a cancelada
  UPDATE reservas 
  SET estado = 'cancelada', cancelada_en = v_ahora
  WHERE id = p_reserva_id;

  -- 5. Generar recuperación
  INSERT INTO recuperaciones (
    usuario_id,
    sesion_cancelada_id,
    modalidad,
    mes_origen,
    anio_origen,
    mes_limite,
    anio_limite,
    estado
  ) VALUES (
    p_usuario_id,
    v_sesion_id,
    v_modalidad,
    v_mes_origen,
    v_anio_origen,
    v_mes_limite,
    v_anio_limite,
    'disponible'
  );

  -- 6. Tareas de limpieza (lista espera, notificaciones)
  PERFORM notificar_hueco_disponible(v_sesion_id);

  RETURN QUERY SELECT true, 'Clase cancelada. Se ha generado una recuperación.';
END;
$func$;

-- =====================================================
-- 3. Función: Usar Recuperación
-- =====================================================

-- Eliminar versión anterior para evitar conflictos de tipo de retorno
DROP FUNCTION IF EXISTS usar_recuperacion(uuid, bigint);

CREATE OR REPLACE FUNCTION usar_recuperacion(
  p_usuario_id UUID,
  p_sesion_id BIGINT
)
RETURNS TABLE (ok BOOLEAN, mensaje TEXT)
LANGUAGE plpgsql
AS $func$
DECLARE
  v_sesion_fecha DATE;
  v_sesion_modalidad TEXT;
  v_capacidad INT;
  v_ocupadas INT;
  v_mes_destino INT;
  v_anio_destino INT;
  v_recuperacion_id BIGINT;
  v_recu_mes_origen INT;
  v_recu_anio_origen INT;
  v_count_usadas_next_month INT;
  v_ya_tiene_reserva BOOLEAN;
BEGIN
  -- 1. Verificar sesión destino
  SELECT fecha, modalidad, capacidad
  INTO v_sesion_fecha, v_sesion_modalidad, v_capacidad
  FROM sesiones 
  WHERE id = p_sesion_id AND cancelada = false;

  IF v_sesion_fecha IS NULL THEN
    RETURN QUERY SELECT false, 'Sesión no encontrada.';
    RETURN;
  END IF;

  v_mes_destino := EXTRACT(MONTH FROM v_sesion_fecha);
  v_anio_destino := EXTRACT(YEAR FROM v_sesion_fecha);

  -- 2. Verificar disponibilidad
  SELECT COUNT(*) INTO v_ocupadas FROM reservas WHERE sesion_id = p_sesion_id AND estado = 'activa';
  
  IF v_ocupadas >= v_capacidad THEN
    RETURN QUERY SELECT false, 'La clase está completa.';
    RETURN;
  END IF;

  -- Verificar si el usuario ya tiene reserva ahí
  IF EXISTS (SELECT 1 FROM reservas WHERE usuario_id = p_usuario_id AND sesion_id = p_sesion_id AND estado = 'activa') THEN
    RETURN QUERY SELECT false, 'Ya tienes reserva en esta clase.';
    RETURN;
  END IF;

  -- 3. Buscar la MEJOR recuperación disponible
  -- Prioridad 1: Recuperación del MISMO mes (no gasta cupo 'next month')
  SELECT id, mes_origen, anio_origen
  INTO v_recuperacion_id, v_recu_mes_origen, v_recu_anio_origen
  FROM recuperaciones
  WHERE usuario_id = p_usuario_id 
    AND estado = 'disponible'
    AND modalidad = v_sesion_modalidad -- Estricto: Focus paga Focus, Reducido paga Reducido
    AND mes_origen = v_mes_destino
    AND anio_origen = v_anio_destino
  LIMIT 1;

  -- Si no hay del mismo mes, buscar del mes anterior (Sujeto a límite)
  IF v_recuperacion_id IS NULL THEN
    
    -- Contar cuántas recuperaciones de meses ANTERIORES se han usado en este mes destino
    -- El límite es 1.
    
    SELECT COUNT(*)
    INTO v_count_usadas_next_month
    FROM recuperaciones
    WHERE usuario_id = p_usuario_id
      AND mes_uso = v_mes_destino
      AND anio_uso = v_anio_destino
      AND (mes_origen != v_mes_destino OR anio_origen != v_anio_destino) -- Origen distinto al destino (arrastradas)
      AND estado = 'usada';

    IF v_count_usadas_next_month >= 1 THEN
      RETURN QUERY SELECT false, 'Ya has usado tu única recuperación permitida del mes anterior para este mes.';
      RETURN;
    END IF;

    -- Buscar una recuperación válida de meses anteriores
    SELECT id, mes_origen, anio_origen
    INTO v_recuperacion_id, v_recu_mes_origen, v_recu_anio_origen
    FROM recuperaciones
    WHERE usuario_id = p_usuario_id
      AND estado = 'disponible'
      AND modalidad = v_sesion_modalidad
      AND (
        (anio_limite > v_anio_destino) OR 
        (anio_limite = v_anio_destino AND mes_limite >= v_mes_destino)
      )
      -- Que NO sea del mismo mes (ya buscamos eso antes y no había)
      AND (mes_origen != v_mes_destino OR anio_origen != v_anio_destino)
    ORDER BY fecha_creacion ASC -- Gastar las más viejas primero
    LIMIT 1;
    
    IF v_recuperacion_id IS NULL THEN
      RETURN QUERY SELECT false, 'No tienes recuperaciones válidas (' || v_sesion_modalidad || ') para esta fecha.';
      RETURN;
    END IF;

  END IF;

  -- 4. Ejecutar uso
  UPDATE recuperaciones
  SET estado = 'usada',
      fecha_uso = NOW(),
      sesion_uso_id = p_sesion_id,
      mes_uso = v_mes_destino,
      anio_uso = v_anio_destino
  WHERE id = v_recuperacion_id;

  INSERT INTO reservas (sesion_id, usuario_id, estado, es_recuperacion, es_desde_horario_fijo)
  VALUES (p_sesion_id, p_usuario_id, 'activa', true, false);

  -- Quitar de lista de espera si estaba
  DELETE FROM lista_espera WHERE usuario_id = p_usuario_id AND sesion_id = p_sesion_id;

  RETURN QUERY SELECT true, 'Recuperación aplicada correctamente.';
END;
$func$;
